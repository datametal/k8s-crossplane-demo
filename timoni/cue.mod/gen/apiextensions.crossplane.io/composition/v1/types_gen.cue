// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f crds/compositions.yaml

package v1

import "strings"

// A Composition specifies how a composite resource should be
// composed.
#Composition: {
	// APIVersion defines the versioned schema of this representation
	// of an object. Servers should convert recognized schemas to the
	// latest internal value, and may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "apiextensions.crossplane.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents. Servers may infer this from the endpoint
	// the client submits requests to. Cannot be updated. In
	// CamelCase. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "Composition"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// CompositionSpec specifies desired state of a composition.
	spec!: #CompositionSpec
}

// CompositionSpec specifies desired state of a composition.
#CompositionSpec: {
	// CompositeTypeRef specifies the type of composite resource that
	// this composition is compatible with.
	compositeTypeRef: {
		// APIVersion of the type.
		apiVersion: string

		// Kind of the type.
		kind: string
	}

	// Environment configures the environment in which resources are
	// rendered.
	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not
	// honored unless the relevant Crossplane feature flag is
	// enabled, and may be changed or removed without notice.
	environment?: {
		// DefaultData statically defines the initial state of the
		// environment. It has the same schema-less structure as the data
		// field in environment configs. It is overwritten by the
		// selected environment configs.
		defaultData?: {
			[string]: _
		}

		// EnvironmentConfigs selects a list of `EnvironmentConfig`s. The
		// resolved resources are stored in the composite resource at
		// `spec.environmentConfigRefs` and is only updated if it is
		// null.
		// The list of references is used to compute an in-memory
		// environment at compose time. The data of all object is merged
		// in the order they are listed, meaning the values of
		// EnvironmentConfigs with a larger index take priority over ones
		// with smaller indices.
		// The computed environment can be accessed in a composition using
		// `FromEnvironmentFieldPath` and `CombineFromEnvironment`
		// patches.
		environmentConfigs?: [...{
			ref?: {
				// The name of the object.
				name: string
			}

			// Selector selects EnvironmentConfig(s) via labels.
			selector?: {
				// MatchLabels ensures an object with matching labels is selected.
				matchLabels?: [...{
					// FromFieldPathPolicy specifies the policy for the
					// valueFromFieldPath. The default is Required, meaning that an
					// error will be returned if the field is not found in the
					// composite resource. Optional means that if the field is not
					// found in the composite resource, that label pair will just be
					// skipped. N.B. other specified label matchers will still be
					// used to retrieve the desired environment config, if any.
					fromFieldPathPolicy?: "Optional" | "Required" | *"Required"

					// Key of the label to match.
					key: string

					// Type specifies where the value for a label comes from.
					type?: "FromCompositeFieldPath" | "Value" | *"FromCompositeFieldPath"

					// Value specifies a literal label value.
					value?: string

					// ValueFromFieldPath specifies the field path to look for the
					// label value.
					valueFromFieldPath?: string
				}]

				// MaxMatch specifies the number of extracted EnvironmentConfigs
				// in Multiple mode, extracts all if nil.
				maxMatch?: int

				// Mode specifies retrieval strategy: "Single" or "Multiple".
				mode?: "Single" | "Multiple" | *"Single"

				// SortByFieldPath is the path to the field based on which list of
				// EnvironmentConfigs is alphabetically sorted.
				sortByFieldPath?: string | *"metadata.name"
			}

			// Type specifies the way the EnvironmentConfig is selected.
			// Default is `Reference`
			type?: "Reference" | "Selector" | *"Reference"
		}]

		// Patches is a list of environment patches that are executed
		// before a composition's resources are composed.
		patches?: [...{
			// Combine is the patch configuration for a CombineFromComposite
			// or CombineToComposite patch.
			combine?: {
				// Strategy defines the strategy to use to combine the input
				// variable values. Currently only string is supported.
				strategy: "string"
				string?: {
					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt: string
				}

				// Variables are the list of variables whose values will be
				// retrieved and combined.
				variables: [...{
					// FromFieldPath is the path of the field on the source whose
					// value is to be used as input.
					fromFieldPath: string
				}] & [_, ...]
			}

			// FromFieldPath is the path of the field on the resource whose
			// value is to be used as input. Required when type is
			// FromCompositeFieldPath or ToCompositeFieldPath.
			fromFieldPath?: string

			// Policy configures the specifics of patching behaviour.
			policy?: {
				// FromFieldPath specifies how to patch from a field path. The
				// default is 'Optional', which means the patch will be a no-op
				// if the specified fromFieldPath does not exist. Use 'Required'
				// if the patch should fail if the specified path does not exist.
				fromFieldPath?: "Optional" | "Required"

				// MergeOptions Specifies merge options on a field path
				mergeOptions?: {
					// Specifies that already existing elements in a merged slice
					// should be preserved
					appendSlice?: bool

					// Specifies that already existing values in a merged map should
					// be preserved
					keepMapValues?: bool
				}
			}

			// ToFieldPath is the path of the field on the resource whose
			// value will be changed with the result of transforms. Leave
			// empty if you'd like to propagate to the same path as
			// fromFieldPath.
			toFieldPath?: string

			// Transforms are the list of functions that are used as a FIFO
			// pipe for the input to be transformed.
			transforms?: [...{
				// Convert is used to cast the input into the given output type.
				convert?: {
					// The expected input format.
					// * `quantity` - parses the input as a K8s
					// [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
					// Only used during `string -> float64` conversions. * `json` -
					// parses the input as a JSON string. Only used during `string ->
					// object` or `string -> list` conversions.
					// If this property is null, the default conversion is applied.
					format?: "none" | "quantity" | "json"

					// ToType is the type of the output of this transform.
					toType: "string" | "int" | "int64" | "bool" | "float64" | "object" | "list"
				}

				// Map uses the input as a key in the given map and returns the
				// value.
				map?: {
					[string]: _
				}

				// Match is a more complex version of Map that matches a list of
				// patterns.
				match?: {
					// Determines to what value the transform should fallback if no
					// pattern matches.
					fallbackTo?: "Value" | "Input" | *"Value"

					// The fallback value that should be returned by the transform if
					// now pattern matches.
					fallbackValue?: _

					// The patterns that should be tested against the input string.
					// Patterns are tested in order. The value of the first match is
					// used as result of this transform.
					patterns?: [...{
						// Literal exactly matches the input string (case sensitive). Is
						// required if `type` is `literal`.
						literal?: string

						// Regexp to match against the input string. Is required if `type`
						// is `regexp`.
						regexp?: string

						// The value that is used as result of the transform if the
						// pattern matches.
						result: _

						// Type specifies how the pattern matches the input.
						// * `literal` - the pattern value has to exactly match (case
						// sensitive) the input string. This is the default.
						// * `regexp` - the pattern treated as a regular expression
						// against which the input string is tested. Crossplane will
						// throw an error if the key is not a valid regexp.
						type: "literal" | "regexp" | *"literal"
					}]
				}

				// Math is used to transform the input via mathematical operations
				// such as multiplication.
				math?: {
					// ClampMax makes sure that the value is not bigger than the given
					// value.
					clampMax?: int

					// ClampMin makes sure that the value is not smaller than the
					// given value.
					clampMin?: int

					// Multiply the value.
					multiply?: int

					// Type of the math transform to be run.
					type?: "Multiply" | "ClampMin" | "ClampMax" | *"Multiply"
				}

				// String is used to transform the input into a string or a
				// different kind of string. Note that the input does not
				// necessarily need to be a string.
				string?: {
					// Optional conversion method to be specified. `ToUpper` and
					// `ToLower` change the letter case of the input string.
					// `ToBase64` and `FromBase64` perform a base64 conversion based
					// on the input string. `ToJson` converts any input value into
					// its raw JSON representation. `ToSha1`, `ToSha256` and
					// `ToSha512` generate a hash value based on the input converted
					// to JSON.
					convert?: "ToUpper" | "ToLower" | "ToBase64" | "FromBase64" | "ToJson" | "ToSha1" | "ToSha256" | "ToSha512"

					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt?: string

					// Extract a match from the input using a regular expression.
					regexp?: {
						// Group number to match. 0 (the default) matches the entire
						// expression.
						group?: int

						// Match string. May optionally include submatches, aka capture
						// groups. See https://pkg.go.dev/regexp/ for details.
						match: string
					}

					// Trim the prefix or suffix from the input
					trim?: string

					// Type of the string transform to be run.
					type?: "Format" | "Convert" | "TrimPrefix" | "TrimSuffix" | "Regexp" | *"Format"
				}

				// Type of the transform to be run.
				type: "map" | "match" | "math" | "string" | "convert"
			}]

			// Type sets the patching behaviour to be used. Each patch type
			// may require its own fields to be set on the Patch object.
			type?: "FromCompositeFieldPath" | "ToCompositeFieldPath" | "CombineFromComposite" | "CombineToComposite" | *"FromCompositeFieldPath"
		}]

		// Policy represents the Resolve and Resolution policies which
		// apply to all EnvironmentSourceReferences in EnvironmentConfigs
		// list.
		policy?: {
			// Resolution specifies whether resolution of this reference is
			// required. The default is 'Required', which means the reconcile
			// will fail if the reference cannot be resolved. 'Optional'
			// means this reference will be a no-op if it cannot be resolved.
			resolution?: "Required" | "Optional" | *"Required"

			// Resolve specifies when this reference should be resolved. The
			// default is 'IfNotPresent', which will attempt to resolve the
			// reference only when the corresponding field is not present.
			// Use 'Always' to resolve the reference on every reconcile.
			resolve?: "Always" | "IfNotPresent"
		}
	}

	// Mode controls what type or "mode" of Composition will be used.
	// "Resources" (the default) indicates that a Composition uses
	// what is commonly referred to as "Patch & Transform" or P&T
	// composition. This mode of Composition uses an array of
	// resources, each a template for a composed resource.
	// "Pipeline" indicates that a Composition specifies a pipeline of
	// Composition Functions, each of which is responsible for
	// producing composed resources that Crossplane should create or
	// update. THE PIPELINE MODE IS A BETA FEATURE. It is not honored
	// if the relevant Crossplane feature flag is disabled.
	mode?: "Resources" | "Pipeline" | *"Resources"

	// PatchSets define a named set of patches that may be included by
	// any resource in this Composition. PatchSets cannot themselves
	// refer to other PatchSets.
	// PatchSets are only used by the "Resources" mode of Composition.
	// They are ignored by other modes.
	patchSets?: [...{
		// Name of this PatchSet.
		name: string

		// Patches will be applied as an overlay to the base resource.
		patches: [...{
			// Combine is the patch configuration for a CombineFromComposite,
			// CombineFromEnvironment, CombineToComposite or
			// CombineToEnvironment patch.
			combine?: {
				// Strategy defines the strategy to use to combine the input
				// variable values. Currently only string is supported.
				strategy: "string"
				string?: {
					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt: string
				}

				// Variables are the list of variables whose values will be
				// retrieved and combined.
				variables: [...{
					// FromFieldPath is the path of the field on the source whose
					// value is to be used as input.
					fromFieldPath: string
				}] & [_, ...]
			}

			// FromFieldPath is the path of the field on the resource whose
			// value is to be used as input. Required when type is
			// FromCompositeFieldPath, FromEnvironmentFieldPath,
			// ToCompositeFieldPath, ToEnvironmentFieldPath.
			fromFieldPath?: string

			// PatchSetName to include patches from. Required when type is
			// PatchSet.
			patchSetName?: string

			// Policy configures the specifics of patching behaviour.
			policy?: {
				// FromFieldPath specifies how to patch from a field path. The
				// default is 'Optional', which means the patch will be a no-op
				// if the specified fromFieldPath does not exist. Use 'Required'
				// if the patch should fail if the specified path does not exist.
				fromFieldPath?: "Optional" | "Required"

				// MergeOptions Specifies merge options on a field path
				mergeOptions?: {
					// Specifies that already existing elements in a merged slice
					// should be preserved
					appendSlice?: bool

					// Specifies that already existing values in a merged map should
					// be preserved
					keepMapValues?: bool
				}
			}

			// ToFieldPath is the path of the field on the resource whose
			// value will be changed with the result of transforms. Leave
			// empty if you'd like to propagate to the same path as
			// fromFieldPath.
			toFieldPath?: string

			// Transforms are the list of functions that are used as a FIFO
			// pipe for the input to be transformed.
			transforms?: [...{
				// Convert is used to cast the input into the given output type.
				convert?: {
					// The expected input format.
					// * `quantity` - parses the input as a K8s
					// [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
					// Only used during `string -> float64` conversions. * `json` -
					// parses the input as a JSON string. Only used during `string ->
					// object` or `string -> list` conversions.
					// If this property is null, the default conversion is applied.
					format?: "none" | "quantity" | "json"

					// ToType is the type of the output of this transform.
					toType: "string" | "int" | "int64" | "bool" | "float64" | "object" | "list"
				}

				// Map uses the input as a key in the given map and returns the
				// value.
				map?: {
					[string]: _
				}

				// Match is a more complex version of Map that matches a list of
				// patterns.
				match?: {
					// Determines to what value the transform should fallback if no
					// pattern matches.
					fallbackTo?: "Value" | "Input" | *"Value"

					// The fallback value that should be returned by the transform if
					// now pattern matches.
					fallbackValue?: _

					// The patterns that should be tested against the input string.
					// Patterns are tested in order. The value of the first match is
					// used as result of this transform.
					patterns?: [...{
						// Literal exactly matches the input string (case sensitive). Is
						// required if `type` is `literal`.
						literal?: string

						// Regexp to match against the input string. Is required if `type`
						// is `regexp`.
						regexp?: string

						// The value that is used as result of the transform if the
						// pattern matches.
						result: _

						// Type specifies how the pattern matches the input.
						// * `literal` - the pattern value has to exactly match (case
						// sensitive) the input string. This is the default.
						// * `regexp` - the pattern treated as a regular expression
						// against which the input string is tested. Crossplane will
						// throw an error if the key is not a valid regexp.
						type: "literal" | "regexp" | *"literal"
					}]
				}

				// Math is used to transform the input via mathematical operations
				// such as multiplication.
				math?: {
					// ClampMax makes sure that the value is not bigger than the given
					// value.
					clampMax?: int

					// ClampMin makes sure that the value is not smaller than the
					// given value.
					clampMin?: int

					// Multiply the value.
					multiply?: int

					// Type of the math transform to be run.
					type?: "Multiply" | "ClampMin" | "ClampMax" | *"Multiply"
				}

				// String is used to transform the input into a string or a
				// different kind of string. Note that the input does not
				// necessarily need to be a string.
				string?: {
					// Optional conversion method to be specified. `ToUpper` and
					// `ToLower` change the letter case of the input string.
					// `ToBase64` and `FromBase64` perform a base64 conversion based
					// on the input string. `ToJson` converts any input value into
					// its raw JSON representation. `ToSha1`, `ToSha256` and
					// `ToSha512` generate a hash value based on the input converted
					// to JSON.
					convert?: "ToUpper" | "ToLower" | "ToBase64" | "FromBase64" | "ToJson" | "ToSha1" | "ToSha256" | "ToSha512"

					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt?: string

					// Extract a match from the input using a regular expression.
					regexp?: {
						// Group number to match. 0 (the default) matches the entire
						// expression.
						group?: int

						// Match string. May optionally include submatches, aka capture
						// groups. See https://pkg.go.dev/regexp/ for details.
						match: string
					}

					// Trim the prefix or suffix from the input
					trim?: string

					// Type of the string transform to be run.
					type?: "Format" | "Convert" | "TrimPrefix" | "TrimSuffix" | "Regexp" | *"Format"
				}

				// Type of the transform to be run.
				type: "map" | "match" | "math" | "string" | "convert"
			}]

			// Type sets the patching behaviour to be used. Each patch type
			// may require its own fields to be set on the Patch object.
			type?: "FromCompositeFieldPath" | "FromEnvironmentFieldPath" | "PatchSet" | "ToCompositeFieldPath" | "ToEnvironmentFieldPath" | "CombineFromEnvironment" | "CombineFromComposite" | "CombineToComposite" | "CombineToEnvironment" | *"FromCompositeFieldPath"
		}]
	}]

	// Pipeline is a list of composition function steps that will be
	// used when a composite resource referring to this composition
	// is created. One of resources and pipeline must be specified -
	// you cannot specify both.
	// The Pipeline is only used by the "Pipeline" mode of
	// Composition. It is ignored by other modes.
	// THIS IS A BETA FIELD. It is not honored if the relevant
	// Crossplane feature flag is disabled.
	pipeline?: [...{
		functionRef: {
			// Name of the referenced Function.
			name: string
		}

		// Input is an optional, arbitrary Kubernetes resource (i.e. a
		// resource with an apiVersion and kind) that will be passed to
		// the Composition Function as the 'input' of its
		// RunFunctionRequest.
		input?: {...}

		// Step name. Must be unique within its Pipeline.
		step: string
	}]

	// PublishConnectionDetailsWithStoreConfig specifies the secret
	// store config with which the connection details of composite
	// resources dynamically provisioned using this composition will
	// be published.
	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not
	// honored unless the relevant Crossplane feature flag is
	// enabled, and may be changed or removed without notice.
	publishConnectionDetailsWithStoreConfigRef?: {
		// Name of the referenced StoreConfig.
		name: string
	} | *{
		name: "default"
	}

	// Resources is a list of resource templates that will be used
	// when a composite resource referring to this composition is
	// created.
	// Resources are only used by the "Resources" mode of Composition.
	// They are ignored by other modes.
	resources?: [...{
		// Base is the target resource that the patches will be applied
		// on.
		base: {}

		// ConnectionDetails lists the propagation secret keys from this
		// target resource to the composition instance connection secret.
		connectionDetails?: [...{
			// FromConnectionSecretKey is the key that will be used to fetch
			// the value from the composed resource's connection secret.
			fromConnectionSecretKey?: string

			// FromFieldPath is the path of the field on the composed resource
			// whose value to be used as input. Name must be specified if the
			// type is FromFieldPath.
			fromFieldPath?: string

			// Name of the connection secret key that will be propagated to
			// the connection secret of the composition instance. Leave empty
			// if you'd like to use the same key name.
			name?: string

			// Type sets the connection detail fetching behaviour to be used.
			// Each connection detail type may require its own fields to be
			// set on the ConnectionDetail object. If the type is omitted
			// Crossplane will attempt to infer it based on which other
			// fields were specified. If multiple fields are specified the
			// order of precedence is: 1. FromValue 2.
			// FromConnectionSecretKey 3. FromFieldPath
			type?: "FromConnectionSecretKey" | "FromFieldPath" | "FromValue"

			// Value that will be propagated to the connection secret of the
			// composite resource. May be set to inject a fixed,
			// non-sensitive connection secret value, for example a
			// well-known port.
			value?: string
		}]

		// A Name uniquely identifies this entry within its Composition's
		// resources array. Names are optional but *strongly*
		// recommended. When all entries in the resources array are named
		// entries may added, deleted, and reordered as long as their
		// names do not change. When entries are not named the length and
		// order of the resources array should be treated as immutable.
		// Either all or no entries must be named.
		name?: string

		// Patches will be applied as overlay to the base resource.
		patches?: [...{
			// Combine is the patch configuration for a CombineFromComposite,
			// CombineFromEnvironment, CombineToComposite or
			// CombineToEnvironment patch.
			combine?: {
				// Strategy defines the strategy to use to combine the input
				// variable values. Currently only string is supported.
				strategy: "string"
				string?: {
					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt: string
				}

				// Variables are the list of variables whose values will be
				// retrieved and combined.
				variables: [...{
					// FromFieldPath is the path of the field on the source whose
					// value is to be used as input.
					fromFieldPath: string
				}] & [_, ...]
			}

			// FromFieldPath is the path of the field on the resource whose
			// value is to be used as input. Required when type is
			// FromCompositeFieldPath, FromEnvironmentFieldPath,
			// ToCompositeFieldPath, ToEnvironmentFieldPath.
			fromFieldPath?: string

			// PatchSetName to include patches from. Required when type is
			// PatchSet.
			patchSetName?: string

			// Policy configures the specifics of patching behaviour.
			policy?: {
				// FromFieldPath specifies how to patch from a field path. The
				// default is 'Optional', which means the patch will be a no-op
				// if the specified fromFieldPath does not exist. Use 'Required'
				// if the patch should fail if the specified path does not exist.
				fromFieldPath?: "Optional" | "Required"

				// MergeOptions Specifies merge options on a field path
				mergeOptions?: {
					// Specifies that already existing elements in a merged slice
					// should be preserved
					appendSlice?: bool

					// Specifies that already existing values in a merged map should
					// be preserved
					keepMapValues?: bool
				}
			}

			// ToFieldPath is the path of the field on the resource whose
			// value will be changed with the result of transforms. Leave
			// empty if you'd like to propagate to the same path as
			// fromFieldPath.
			toFieldPath?: string

			// Transforms are the list of functions that are used as a FIFO
			// pipe for the input to be transformed.
			transforms?: [...{
				// Convert is used to cast the input into the given output type.
				convert?: {
					// The expected input format.
					// * `quantity` - parses the input as a K8s
					// [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
					// Only used during `string -> float64` conversions. * `json` -
					// parses the input as a JSON string. Only used during `string ->
					// object` or `string -> list` conversions.
					// If this property is null, the default conversion is applied.
					format?: "none" | "quantity" | "json"

					// ToType is the type of the output of this transform.
					toType: "string" | "int" | "int64" | "bool" | "float64" | "object" | "list"
				}

				// Map uses the input as a key in the given map and returns the
				// value.
				map?: {
					[string]: _
				}

				// Match is a more complex version of Map that matches a list of
				// patterns.
				match?: {
					// Determines to what value the transform should fallback if no
					// pattern matches.
					fallbackTo?: "Value" | "Input" | *"Value"

					// The fallback value that should be returned by the transform if
					// now pattern matches.
					fallbackValue?: _

					// The patterns that should be tested against the input string.
					// Patterns are tested in order. The value of the first match is
					// used as result of this transform.
					patterns?: [...{
						// Literal exactly matches the input string (case sensitive). Is
						// required if `type` is `literal`.
						literal?: string

						// Regexp to match against the input string. Is required if `type`
						// is `regexp`.
						regexp?: string

						// The value that is used as result of the transform if the
						// pattern matches.
						result: _

						// Type specifies how the pattern matches the input.
						// * `literal` - the pattern value has to exactly match (case
						// sensitive) the input string. This is the default.
						// * `regexp` - the pattern treated as a regular expression
						// against which the input string is tested. Crossplane will
						// throw an error if the key is not a valid regexp.
						type: "literal" | "regexp" | *"literal"
					}]
				}

				// Math is used to transform the input via mathematical operations
				// such as multiplication.
				math?: {
					// ClampMax makes sure that the value is not bigger than the given
					// value.
					clampMax?: int

					// ClampMin makes sure that the value is not smaller than the
					// given value.
					clampMin?: int

					// Multiply the value.
					multiply?: int

					// Type of the math transform to be run.
					type?: "Multiply" | "ClampMin" | "ClampMax" | *"Multiply"
				}

				// String is used to transform the input into a string or a
				// different kind of string. Note that the input does not
				// necessarily need to be a string.
				string?: {
					// Optional conversion method to be specified. `ToUpper` and
					// `ToLower` change the letter case of the input string.
					// `ToBase64` and `FromBase64` perform a base64 conversion based
					// on the input string. `ToJson` converts any input value into
					// its raw JSON representation. `ToSha1`, `ToSha256` and
					// `ToSha512` generate a hash value based on the input converted
					// to JSON.
					convert?: "ToUpper" | "ToLower" | "ToBase64" | "FromBase64" | "ToJson" | "ToSha1" | "ToSha256" | "ToSha512"

					// Format the input using a Go format string. See
					// https://golang.org/pkg/fmt/ for details.
					fmt?: string

					// Extract a match from the input using a regular expression.
					regexp?: {
						// Group number to match. 0 (the default) matches the entire
						// expression.
						group?: int

						// Match string. May optionally include submatches, aka capture
						// groups. See https://pkg.go.dev/regexp/ for details.
						match: string
					}

					// Trim the prefix or suffix from the input
					trim?: string

					// Type of the string transform to be run.
					type?: "Format" | "Convert" | "TrimPrefix" | "TrimSuffix" | "Regexp" | *"Format"
				}

				// Type of the transform to be run.
				type: "map" | "match" | "math" | "string" | "convert"
			}]

			// Type sets the patching behaviour to be used. Each patch type
			// may require its own fields to be set on the Patch object.
			type?: "FromCompositeFieldPath" | "FromEnvironmentFieldPath" | "PatchSet" | "ToCompositeFieldPath" | "ToEnvironmentFieldPath" | "CombineFromEnvironment" | "CombineFromComposite" | "CombineToComposite" | "CombineToEnvironment" | *"FromCompositeFieldPath"
		}]

		// ReadinessChecks allows users to define custom readiness checks.
		// All checks have to return true in order for resource to be
		// considered ready. The default readiness check is to have the
		// "Ready" condition to be "True".
		readinessChecks?: [...{
			// FieldPath shows the path of the field whose value will be used.
			fieldPath?: string

			// MatchCondition specifies the condition you'd like to match if
			// you're using "MatchCondition" type.
			matchCondition?: {
				// Status is the status of the condition you'd like to match.
				status: string | *"True"

				// Type indicates the type of condition you'd like to use.
				type: string | *"Ready"
			}

			// MatchInt is the value you'd like to match if you're using
			// "MatchInt" type.
			matchInteger?: int

			// MatchString is the value you'd like to match if you're using
			// "MatchString" type.
			matchString?: string

			// Type indicates the type of probe you'd like to use.
			type: "MatchString" | "MatchInteger" | "NonEmpty" | "MatchCondition" | "MatchTrue" | "MatchFalse" | "None"
		}] | *[{
			matchCondition: {
				status: "True"
				type:   "Ready"
			}
			type: "MatchCondition"
		}]
	}]

	// WriteConnectionSecretsToNamespace specifies the namespace in
	// which the connection secrets of composite resource dynamically
	// provisioned using this composition will be created. This field
	// is planned to be replaced in a future release in favor of
	// PublishConnectionDetailsWithStoreConfigRef. Currently, both
	// could be set independently and connection details would be
	// published to both without affecting each other as long as
	// related fields at MR level specified.
	writeConnectionSecretsToNamespace?: string
}
